다음 몇 개의 챕터에 걸쳐서 우리의 첫 번째 삼각형을 그리도록 구성된 그래픽스 파이프라인을 설정할 것입니다. 그래픽스 파이프라인은 메시의 정점(vertices)과 텍스처(textures)를 가져와 렌더 타겟의 픽셀에 이르기까지의 일련의 연산 과정입니다. 아래에 간략한 개요가 표시됩니다:

![](/images/vulkan_simplified_pipeline.svg)

*입력 조립기(input assembler)*는 지정한 버퍼로부터 원시 정점 데이터(raw vertex data)를 수집하고, 정점 데이터를 복제할 필요 없이 특정 요소를 반복하기 위해 인덱스 버퍼를 사용할 수도 있습니다.

*정점 셰이더(vertex shader)*는 모든 정점에 대해 실행되며, 일반적으로 정점 위치를 모델 공간(model space)에서 화면 공간(screen space)으로 변환하는 작업을 적용합니다. 또한 정점별(per-vertex) 데이터를 파이프라인의 다음 단계로 전달합니다.

*테셀레이션 셰이더(tessellation shaders)*를 사용하면 특정 규칙에 따라 지오메트리를 세분화하여 메시 품질을 높일 수 있습니다. 이는 종종 벽돌 벽이나 계단과 같은 표면이 가까이 있을 때 덜 평평하게 보이도록 만드는 데 사용됩니다.

*지오메트리 셰이더(geometry shader)*는 모든 프리미티브(삼각형, 선, 점)에 대해 실행되며, 이를 버리거나 입력된 것보다 더 많은 프리미티브를 출력할 수 있습니다. 이는 테셀레이션 셰이더와 유사하지만 훨씬 더 유연합니다. 하지만 인텔의 내장 GPU를 제외한 대부분의 그래픽 카드에서 성능이 그리 좋지 않기 때문에 오늘날의 애플리케이션에서는 많이 사용되지 않습니다.

*래스터화(rasterization)* 단계는 프리미티브를 *프래그먼트(fragments)*로 이산화합니다. 이것들은 프리미티브가 프레임버퍼에서 채우는 픽셀 요소입니다. 화면 밖으로 벗어나는 모든 프래그먼트는 버려지며, 정점 셰이더에서 출력된 속성들은 그림과 같이 프래그먼트들에 걸쳐 보간됩니다. 일반적으로 다른 프리미티브 프래그먼트 뒤에 있는 프래그먼트들도 깊이 테스팅(depth testing) 때문에 여기서 버려집니다.

*프래그먼트 셰이더(fragment shader)*는 살아남은 모든 프래그먼트에 대해 호출되며, 프래그먼트가 어떤 프레임버퍼에 어떤 색상과 깊이 값으로 쓰일지를 결정합니다. 이 작업은 정점 셰이더로부터 보간된 데이터를 사용하여 수행할 수 있으며, 이 데이터에는 텍스처 좌표나 조명을 위한 노멀(normals)과 같은 것들이 포함될 수 있습니다.

*색상 혼합(color blending)* 단계는 프레임버퍼의 동일한 픽셀에 매핑되는 다른 프래그먼트들을 혼합하는 연산을 적용합니다. 프래그먼트들은 단순히 서로를 덮어쓰거나, 더해지거나, 투명도에 따라 혼합될 수 있습니다.

녹색으로 표시된 단계는 *고정 함수(fixed-function)* 단계로 알려져 있습니다. 이 단계들은 매개변수를 사용하여 연산을 조정할 수 있지만, 작동 방식은 미리 정의되어 있습니다.

반면에 주황색으로 표시된 단계는 `프로그래밍 가능(programmable)`하며, 이는 그래픽 카드에 자신만의 코드를 업로드하여 원하는 연산을 정확하게 적용할 수 있음을 의미합니다. 예를 들어, 이를 통해 프래그먼트 셰이더를 사용하여 텍스처링과 조명부터 레이 트레이서에 이르기까지 무엇이든 구현할 수 있습니다. 이러한 프로그램들은 많은 GPU 코어에서 동시에 실행되어 정점이나 프래그먼트 같은 많은 객체들을 병렬적으로 처리합니다.

만약 OpenGL이나 Direct3D와 같은 이전 API를 사용해 본 적이 있다면, `glBlendFunc`나 `OMSetBlendState`와 같은 호출로 언제든지 파이프라인 설정을 변경할 수 있는 것에 익숙할 것입니다. Vulkan의 그래픽스 파이프라인은 거의 완전히 불변(immutable)이므로, 셰이더를 변경하거나, 다른 프레임버퍼를 바인딩하거나, 혼합 함수를 변경하려면 파이프라인을 처음부터 다시 생성해야 합니다. 단점은 렌더링 작업에서 사용하려는 모든 다른 상태 조합을 나타내는 여러 개의 파이프라인을 만들어야 한다는 것입니다. 하지만 파이프라인에서 수행할 모든 작업이 미리 알려져 있기 때문에, 드라이버가 훨씬 더 잘 최적화할 수 있습니다.

프로그래밍 가능한 단계 중 일부는 여러분이 하려는 작업에 따라 선택적입니다. 예를 들어, 간단한 지오메트리만 그리는 경우 테셀레이션 및 지오메트리 단계를 비활성화할 수 있습니다. 만약 깊이 값에만 관심이 있다면 프래그먼트 셰이더 단계를 비활성화할 수 있으며, 이는 [그림자 맵(shadow map)](https://en.wikipedia.org/wiki/Shadow_mapping) 생성에 유용합니다.

다음 챕터에서는 먼저 화면에 삼각형을 올리는 데 필요한 두 가지 프로그래밍 가능 단계인 정점 셰이더와 프래그먼트 셰이더를 생성할 것입니다. 혼합 모드, 뷰포트, 래스터화와 같은 고정 함수 구성은 그 다음 챕터에서 설정할 것입니다. Vulkan에서 그래픽스 파이프라인을 설정하는 마지막 부분은 입력 및 출력 프레임버퍼를 지정하는 것을 포함합니다.

`initVulkan`에서 `createImageViews` 바로 뒤에 호출되는 `createGraphicsPipeline` 함수를 만드세요. 우리는 다음 챕터들 내내 이 함수를 작업할 것입니다.

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createGraphicsPipeline();
}

...

void createGraphicsPipeline() {

}
```

[C++ 코드](/code/08_graphics_pipeline.cpp)